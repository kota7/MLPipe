% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/feature-standardize.R
\name{feature_standardizer}
\alias{FeatureStandardizer}
\alias{feature_standardizer}
\title{Feature-wise standardization}
\description{
Standardize each feature of data. Three methodologies are supported:
\itemize{
\item{"l2": standardize to zero-mean, unit-variance}
\item{"l1": standardize to zero-mean, unit-MAD (mean absolute deviation)}
\item{"range": standardize to unit interval range}
}
}
\section{Usage}{

\preformatted{feature_standardizer(method = 'l2', tol = sqrt(.Machine$double.eps)}
}

\section{Arguments}{

\describe{
\item{method}{either "l2", "l1" or "range"}
\item{tol}{positive real number, scaling is not conducted if scale is below this level}
}
}

\section{Value}{

\code{FeatureStandardizer} class object
}

\section{Class Methods}{

\describe{
\item{\preformatted{fit(x, y = NULL)}}{fit to \code{x} and store the center and scale values}
\item{\preformatted{transform(x, y = NULL)}}{returns standardized \code{x} matrix}
\item{\preformatted{inv_transform(x, y = NULL)}}{returns pre-standardized \code{x} matrix}
\item{\preformatted{incr_fit(x, y = NULL)}}{currently not implemented}
}
}

\section{Details}{

When fitted to data, the feature-wise centers and scales are stored in the object,
and transformation is conducted using these center and scale values.
Therefore, when applied to new data, they are not exactly standardized.

Uses \code{\link[lsr]{aad}} as the backend calculation for "l1" method
}
\examples{
data(mtcars)
# zero-mean, unit-variance standardization
fs <- feature_standardizer(method='l2')
fs$fit(mtcars)
z <- fs$transform(mtcars)$x
apply(z, MARGIN=2, FUN=mean)
apply(z, MARGIN=2, FUN=sd)
w <- fs$inv_transform(z)$x
range(mtcars-w)

# zero-mean, unit-MAD (mean absolute deviation)
fs <- feature_standardizer(method='l1')
fs$fit(mtcars)
z <- fs$transform(mtcars)$x
apply(z, MARGIN=2, FUN=mean)
apply(z, MARGIN=2, FUN=lsr::aad)
w <- fs$inv_transform(z)$x
range(mtcars-w)

# standardize to unit interval
fs$set_parameters(method='range')
fs$fit(mtcars)
z <- fs$transform(mtcars)$x
apply(z, MARGIN=2, FUN=range)
w <- fs$inv_transform(z)$x
range(mtcars-w)

# incremental fit is allowed for l2 and range method
fs$set_parameters(method='l2')
fs$fit(mtcars)
fs2 <- feature_standardizer(method='l2')
fs2$incr_fit(mtcars[1:10,])
fs2$incr_fit(mtcars[11:32,])
cbind(fs$centers, fs2$centers)
cbind(fs$scales, fs2$scales)

fs$set_parameters(method='range')
fs$fit(mtcars)
fs2$set_parameters(method='range')
fs2$incr_fit(mtcars[1:14,])
fs2$incr_fit(mtcars[15:32,])
cbind(fs$centers, fs2$centers)
cbind(fs$scales, fs2$scales)
}

